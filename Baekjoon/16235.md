## ğŸŒ± ë‚˜ë¬´ ì¬í…Œí¬

#### ì•Œê³ ë¦¬ì¦˜ ë¶„ë¥˜

- êµ¬í˜„
- ìë£Œ êµ¬ì¡°
- ì‹œë®¬ë ˆì´ì…˜

### ë¬¸ì œ

https://www.acmicpc.net/problem/16235

### í’€ì´ ì½”ë“œ

- `int[][] land` : ê°€ì§€ê³  ìˆëŠ” ë•…ì˜ ì–‘ë¶„ì— ëŒ€í•´ ì €ì¥í•˜ëŠ” ë°°ì—´
- `int[][] food` : ê²¨ìš¸ë§ˆë‹¤ ì¶”ê°€ë˜ëŠ” ì–‘ë¶„ì„ ì €ì¥í•˜ëŠ” ë°°ì—´
- `ArrayList<Tree> tree` : ì‹¬ì–´ì§„ ë‚˜ë¬´ ê°ì²´ë¥¼ ì €ì¥í•˜ëŠ” ë¦¬ìŠ¤íŠ¸
  - í´ë˜ìŠ¤ `Tree`ëŠ” ë‚˜ë¬´ê°€ ì‹¬ì–´ì§„ í–‰ë²ˆí˜¸, ì—´ë²ˆí˜¸, ë‚˜ì´, ì‚´ì•„ìˆëŠ”ì§€ ì—¬ë¶€ë¥¼ ì •ë³´ë¡œ ê°€ì§€ê³  ìˆìŒ

#### í•µì‹¬

ì œí•œ ì‹œê°„ì´ ì§§ê¸° ë•Œë¬¸ì— `spring` ë©”ì„œë“œì—ì„œ ë‚˜ë¬´ë“¤ì—ê²Œ ì–‘ë¶„ì„ ì¤„ ë•Œë§ˆë‹¤ `Collection.sort()`ë¥¼ ì‚¬ìš©í•˜ë©´ ì‹œê°„ ì´ˆê³¼ê°€ ë‚œë‹¤. ì •ë ¬ì€ ì´ˆê¸°ì— ì‹¬ì–´ì§„ ë‚˜ë¬´ë¥¼ ì…ë ¥ë°›ê³  í•œ ë²ˆë§Œ ì‚¬ìš©  
-> `autumn`ì—ì„œ ìƒˆë¡œ ì‹¬ì–´ì§„ ë‚˜ë¬´ë“¤ì„ ì €ì¥í•  ìƒˆë¡œìš´ ë¦¬ìŠ¤íŠ¸ `newTree`ë¥¼ ë§Œë“ ë‹¤. ì´ë•Œ ì‹¬ì–´ì§„ ë‚˜ë¬´ë“¤ì€ ëª¨ë‘ ë‚˜ì´ê°€ 1ì´ë¯€ë¡œ ë”°ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬í•  í•„ìš”ê°€ ì—†ë‹¤. ì´í›„ `newTree`ì— ê¸°ì¡´ ë‚˜ë¬´ ì¤‘ì— ì‚´ì•„ ìˆëŠ” ë‚˜ë¬´ë“¤ì„ `add`í•´ì£¼ë©´ ìì—°ìŠ¤ë ˆ ì˜¤ë¦„ì°¨ìˆœì´ ëœë‹¤.  
-> `tree`ì— `newTree` ì£¼ì†Œë¥¼ ì—°ê²°í•´ ìƒˆë¡œ ì‹¬ì–´ì§„ ë‚˜ë¬´ë“¤ì„ í¬í•¨í•œ ë‚˜ë¬´ ë¦¬ìŠ¤íŠ¸ë¡œ ë°”ê¿”ì¤€ë‹¤.

ê°€ì„ ë©”ì„œë“œë¥¼ êµ¬í˜„í•˜ë©´ì„œ ê°€ì¥ ë§ì€ ë¡œì§ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆëŠ”ë°, ì½”ë“œì— ì£¼ì„ìœ¼ë¡œ ë‹¬ì•„ë†“ìŒ

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

public class Main {
	static int[][] land;
	static int[][] food;
	static ArrayList<Tree> tree;
	static int N;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		// ë•…ì˜ í¬ê¸° N*N
        N = sc.nextInt();
        // ì‹¬ì–´ì§„ ë‚˜ë¬´ì˜ ê°œìˆ˜
		int M = sc.nextInt();
        // Kë…„ì´ ì§€ë‚œ í›„ ë‚˜ë¬´ì˜ ê°œìˆ˜ë¥¼ ì¶œë ¥
		int K = sc.nextInt();
		land = new int[N + 1][N + 1];
		food = new int[N + 1][N + 1];
		tree = new ArrayList<>();
        // ì´ˆê¸° ë•…ì— ìˆëŠ” ì–‘ë¶„ì€ 5
        // ê²¨ìš¸ë§ˆë‹¤ ì¶”ê°€ë˜ëŠ” ì–‘ë¶„ì€ ì…ë ¥ê°’ìœ¼ë¡œ ì£¼ì–´ì§
		for (int i = 1; i <= N; i++) {
			for (int j = 1; j <= N; j++) {
				land[i][j] = 5;
				food[i][j] = sc.nextInt();
			}
		}
        // ì‹¬ì–´ì§„ ë‚˜ë¬´ì˜ í–‰ë²ˆí˜¸, ì—´ë²ˆí˜¸, ë‚˜ì´ë¥¼ ì…ë ¥ë°›ì•„ ë¦¬ìŠ¤íŠ¸ì— ê°ì²´ë¥¼ ìƒì„±
		for (int i = 0; i < M; i++) {
			int r = sc.nextInt();
			int c = sc.nextInt();
			int age = sc.nextInt();
			tree.add(new Tree(r, c, age));
		}
        // ì²˜ìŒì— ì‹¬ì–´ì§„ ë‚˜ë¬´ë¥¼ ë‚˜ì´ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬(ì–´ë¦° ë‚˜ë¬´ë¶€í„° ì–‘ë¶„ì„ ë¨¹ì–´ì•¼í•¨)
		Collections.sort(tree);

        // Kë…„ë™ì•ˆ ë´„, ì—¬ë¦„, ê°€ì„, ê²¨ìš¸ í•˜ë‚˜ì˜ ì‚¬ì´í´ì„ ë°˜ë³µí•œë‹¤
		while (K-- > 0) {
			spring();
			summer();
			autumn();
			winter();
		}
		System.out.println(tree.size());
	}

	static void spring() {
		for (Tree t : tree) {
			if (land[t.r][t.c] >= t.age) {
				land[t.r][t.c] -= t.age;
				t.age++;
			} else {
				t.alive = false;
			}
		}
	}

	static void summer() {
		for (Tree t : tree) {
			if (!t.alive) {
				land[t.r][t.c] += t.age / 2;
			}
		}
	}

	static void autumn() {
		int[] x = { -1, -1, -1, 0, 0, 1, 1, 1 };
		int[] y = { -1, 0, 1, -1, 1, -1, 0, 1 };
		ArrayList<Tree> newTree = new ArrayList<>();
		for (Tree t : tree) {
            /*
            ì²˜ìŒì— ì´ë¶€ë¶„ì—ì„œ t.aliveë¥¼ í™•ì¸í•˜ì§€ ì•Šì•„ ë‹¤ë¥¸ ì¶œë ¥ê°’ì´ ë„ì¶œë˜ì—ˆë‹¤. treeì—ëŠ” ì›ë˜ ì‚´ì•„ìˆëŠ” ë‚˜ë¬´ë“¤ë§Œ ìˆì§€ë§Œ springë©”ì„œë“œì˜ ê³¼ì •ì„ ê±°ì¹˜ë©´ì„œ ì£½ì€ ë‚˜ë¬´ê°€ ë°œìƒí•  ìˆ˜ ìˆìŒ
            */
			if (t.alive && t.age % 5 == 0) {
				for (int k = 0; k < x.length; k++) {
					int nx = t.r + x[k];
					int ny = t.c + y[k];
                    /*
                    ì™¼,ìœ„ìª½ ëê²½ê³„(0,y),(x,0)ë§Œ ìƒê°í•´ì„œ ArrayIndexOutBound ì—ëŸ¬ ë°œìƒí•¨.
                    ì•„ë˜, ì˜¤ë¥¸ìª½ ê²½ê³„ë„ ì²˜ë¦¬ë¥¼ í•´ì¤˜ì•¼í•¨(N+1,y),(x,N+1)
                    */
					if ((nx != 0 && ny != 0) && (nx != N + 1 && ny != N + 1)) {
						newTree.add(new Tree(nx, ny, 1));
					}
				}
			}
		}
		for (Tree t : tree) {
			if (t.alive)
				newTree.add(t);
		}
		tree = newTree;
	}

	static void winter() {
		for (int i = 1; i <= N; i++) {
			for (int j = 1; j <= N; j++) {
				land[i][j] += food[i][j];
			}
		}
	}
}

class Tree implements Comparable<Tree> {
	int r, c;
	int age;
	boolean alive;

	Tree(int r, int c, int age) {
		this.r = r;
		this.c = c;
		this.age = age;
		this.alive = true;
	}

	@Override
	public int compareTo(Tree o) {
		return this.age - o.age;
	}
}
```
